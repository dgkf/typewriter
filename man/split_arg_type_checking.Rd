% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/type_syntax.R
\name{split_arg_type_checking}
\alias{split_arg_type_checking}
\title{Split type definitions from parameter defaults}
\usage{
split_arg_type_checking(expr, depth = 0L)
}
\arguments{
\item{expr}{An expression to split based on last \code{:}}

\item{depth}{Recursion depth (not expected to be passed by a user)}
}
\value{
A list with named fields \code{value} and \code{type}, containing the default
value specification and type split from the provided definition. If a value
is equal to \code{.} it is considered as a placeholder and returns an empty list.
}
\description{
In order to use the \code{:} operator as a delimiter for type annotations, some
syntax-tree rearrangement must happen to account for this operator's high
precedence. This function takes an expression and splits it based on the last
surface-level \code{:} not followed by a numeric atomic value.
}
\note{
This assumes that the \code{:} is only implemented for numeric ranges. For
now, that is a safe assumption, but if a package implements a character or
symbol range, this assumption may result in improper interpretation of valid
parameter defaults as type definitions.
}
\examples{
split_arg_type_checking(quote("default" :character))
split_arg_type_checking(quote(1:3 :numeric(length=3)))
split_arg_type_checking(quote(list(1, 1:2, 1:3) :list(lengths=1:3)))
split_arg_type_checking(quote(. :character))

}
\seealso{
Other type_parsing: 
\code{\link{split_fn_type_checking}()}
}
\concept{type_parsing}
